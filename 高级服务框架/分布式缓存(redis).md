# 0. 分布式缓存

基于Redis集群解决单机Redis存在的问题
单机的Redis存在四大问题：

![[Pasted image 20220118184650.png]]

# 1. Redis持久化

Redis有两种持久化方案：

-   RDB持久化
    
-   AOF持久化

## 1.1 RDB持久化

RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录

### 1.1.1 执行时机

RDB持久化在四种情况下会执行：

-   执行save命令
    
-   执行bgsave命令
    
-   Redis停机时
    
-   触发RDB条件时

#### 1.1.1.1 save命令

执行下面的命令，可以立即执行一次RDB：

![[Pasted image 20220118185414.png]]

- 由redis**主线程执行**RDB, 会**阻塞**所有命令

- save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。

#### 1.1.1.2 bgsave命令

下面的命令可以异步执行RDB：

![[Pasted image 20220118185610.png]]

- **开启子进程**执行RDB, 避免主进程收到影响

- 这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。

#### 1.1.1.3 停机时

Redis停机时会执行一次save命令，实现RDB持久化。

1.1.1.4 触发RDB条件(可自主配置)

Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：

```properties
# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB
save 900 1  
save 300 10  
save 60 10000 
```

RDB的其它配置也可以在redis.conf文件中设置：

```properties
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱
rdbcompression yes

# RDB文件名称
dbfilename dump.rdb  

# 文件保存的路径目录
dir ./ 
```

### 1.1.2 RDB原理

bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。

fork采用的是copy-on-write技术：

-   当主进程执行读操作时，访问共享内存；
    
-   当主进程执行写操作时，则会拷贝一份数据，执行写操作。


![[Pasted image 20220118191835.png]]

#### 1.1.2.1 RDB原理自我总结

**名词解释**:

页表: 是一个映射到内存区的一种手段, 操作页表也就是超控物理内存

1. bgsave开始时会fork主进程得到子进程, 此时别的请求是进不来的, 以免导致数据的不一致
2. 然后子进程开始对内存中的数据(read-only状态)进行读操作, 写到新的RDB文件(写完会替换旧Rdb文件)
3. 主进程有两个状态
- 读数据: 可以和子进程共享内存的数据(read-only状态)
- 写数据: 因为内存的数据为read-only状态, 不能进行写操作, 这时会拷贝出来内存的数据一份(所以在一瞬间会存在**内存溢出**, **会判断修改/新增/删除的key在第几页, 把这一页复制出来当做副本**), 主进程只会对这个副本进行写(修改)操作, 保证了子进程的无误差读取read-only状态的内容
4. 当子进程读取完read-only状态的数据, 现在存在了主线程写(修改)的副本数据与子进程读取的read-only状态的数据, 这俩数据会存在差异, 后面会进行一个相当于整合的操作

